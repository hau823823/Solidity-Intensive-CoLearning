9月26日

第五节：变量数据存储和作用域

1、Solidity中的引用类型​(Reference Type)：包括数组（array）和结构体（struct）

2、Solidity数据存储位置有三类：storage，memory和calldata。
1）storage：合约里的状态变量默认都是storage，存储在链上（类似计算机的硬盘），数据是持久化的，消耗gas多；
2）memory：函数里的参数和临时变量一般用memory，存储在内存中，不上链（一旦函数执行完毕，数据会被销毁），消耗gas少。尤其是如果返回数据类型是变长的情况下，必须加memory修饰，例如：string, bytes, array和自定义结构。
3）calldata：和memory类似，存储在内存中，不上链，消耗gas少。与memory的不同点在于calldata变量不能修改（immutable），一般用于函数的参数。

3、当变量赋值时，有两种可能的情况：

1）创建副本：即使对新变量进行修改，也不会影响原始变量。
2）创建引用：新变量与原始变量指向同一块存储空间，修改新变量会影响原始变量。

4、赋值行为取决于变量所在的数据位置，规则如下：

1）Storage 赋值给本地的 storage 变量时，赋值的是引用，改变新变量会影响原始变量。
2）Storage 赋值给本地的 memory 变量时，赋值的是副本，修改新变量不会影响原始变量。
3）memory赋值给memory，会创建引用，改变新变量会影响原变量

5、变量按作用域划分有三种：状态变量（state variable），局部变量（local variable）和全局变量(global variable)

1）状态变量：是存储在区块链上的变量。因为这些变量保存在链上，所以对它们的访问和修改都会消耗一定的 gas。状态变量声明在合约内部，且可以在合约的所有函数中被访问和修改。

问题1：状态变量在合约内、函数外声明是什么意思？

GPT答：

合约内：状态变量是合约的一部分，它们在合约体内声明。状态变量存储在区块链上，并且是合约的持久数据。
函数外：状态变量不是在任何函数体内部声明的，而是直接声明在合约的最外层。与函数内部的局部变量不同，状态变量在合约的全局作用域中，这意味着它们可以在合约的任何函数中被访问和修改。

2）局部变量：是仅在函数执行过程中有效的变量，函数退出后，变量无效。局部变量的数据存储在内存里，不上链，gas低。
局部变量在函数内声明：局部变量的生命周期仅限于该函数的执行期间，函数执行完毕后，局部变量就会被销毁，不能在合约的其他部分（包括其他函数）中使用。这些变量存在于**内存（memory）**中，并且这些变量不会被存储在区块链上。
3）全局变量是在 Solidity 中预定义的变量，开发者可以在合约的函数中直接使用这些变量，而不需要显式声明。

常用的全局变量：
blockhash(uint blockNumber): (bytes32) 给定区块的哈希值 – 只适用于256最近区块, 不包含当前区块。
block.coinbase: (address payable) 当前区块矿工的地址
block.gaslimit: (uint) 当前区块的gaslimit
block.number: (uint) 当前区块的number
block.timestamp: (uint) 当前区块的时间戳，为unix纪元以来的秒
gasleft(): (uint256) 剩余 gas
msg.data: (bytes calldata) 完整call data
msg.sender: (address payable) 消息发送者 (当前 caller)
msg.sig: (bytes4) calldata的前四个字节 (function identifier)
msg.value: (uint) 当前交易发送的 wei 值
block.blobbasefee: (uint) 当前区块的blob基础费用。这是Cancun升级新增的全局变量。
blobhash(uint index): (bytes32) 返回跟当前交易关联的第 index 个blob的版本化哈希（第一个字节为版本号，当前为0x01，后面接KZG承诺的SHA256哈希的最后31个字节）。若当前交易不包含blob，则返回空字节。这是Cancun升级新增的全局变量。


以太单位​
Solidity中不存在小数点，以0代替为小数点，来确保交易的精确度，并且防止精度的损失，利用以太单位可以避免误算的问题，方便程序员在合约中处理货币交易
wei: 1
gwei: 1e9 = 1000000000
ether: 1e18 = 1000000000000000000

时间单位​
seconds: 1
minutes: 60 seconds = 60
hours: 60 minutes = 3600
days: 24 hours = 86400
weeks: 7 days = 604800


第六节：引用类型

1、数组（Array）是Solidity常用的一种变量类型，用来存储一组数据（整数，字节，地址等等）。分为固定长度数组和可变长度数组两种：

1）固定长度数组：在声明时指定数组的长度。用T[k]的格式声明，其中T是元素的类型，k是长度；示例：
// 固定长度 Array
uint[8] array1;
bytes1[5] array2;
address[100] array3;

2）可变长度数组（动态数组）：在声明时不指定数组的长度。用T[ ]的格式声明，其中T是元素的类型，示例：
// 可变长度 Array
uint[ ] array4;
bytes1[ ] array5;
address[ ] array6;
bytes array7;

注意：bytes比较特殊，是数组，但是不用加[ ]。另外，不能用byte[ ]声明单字节数组，可以使用bytes或bytes1[ ]。bytes 比 bytes1[ ]省gas。

2、创建数组的规则
1）对于memory修饰的动态数组，可以用new操作符来创建，但是必须声明长度，并且声明后长度不能改变。

示例：
// memory动态数组
uint[] memory array8 = new uint[](5);
bytes memory array9 = new bytes(9);

2）Solidity 的编译器在处理数组字面常数时，会根据数组中元素的类型来决定整个数组的类型。如果没有明确指定类型，编译器会选择能够适应所有元素的最小类型。对于整数，这个最小类型是 uint8。

3）编译器首先检查数组字面常数的第一个元素的类型。如果第一个元素没有显式指定类型，编译器会继续检查其他元素，并选择能够表示所有元素的最小类型。

4）如果第一个元素的类型明确指定了（例如 uint(1)），编译器会将所有后续元素转换为与第一个元素类型一致的类型。

3、数组成员​
1）length: 数组有一个包含元素数量的length成员，memory数组的长度在创建后是固定的。
2）push(): 动态数组拥有push()成员，可以在数组最后添加一个0元素，并返回该元素的引用。
3）push(x): 动态数组拥有push(x)成员，可以在数组最后添加一个x元素。
4）pop(): 动态数组拥有pop()成员，可以移除数组最后一个元素。

4、结构体：Solidity 支持通过结构体的形式来定义新的类型。结构体中的元素可以是基本类型（如 uint、bool、address 等），也可以是引用类型（如数组、映射等）。结构体允许开发者将多个相关的变量组合在一起，形成一个新的复合数据类型。

5、给结构体赋值的四种方法：
1）使用 storage 引用：这种方式适合在函数内部修改合约状态变量的场景。这样可以减少内存拷贝的开销，并且能直接操作状态变量。
2）直接修改状态变量：当需要简单地修改状态变量的某些字段时，直接使用这种方法非常方便。
3）使用构造函数式的赋值：需要同时赋值多个字段时，使用这种构造函数式的赋值方式可以让代码更简洁、清晰
4）使用 key-value 对的形式赋值：当结构体字段较多，且不需要对所有字段赋值时，使用这种 key-value 方式可以显式地为某些特定字段赋值，而不必依赖字段的顺序。
